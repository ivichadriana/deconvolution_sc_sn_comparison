#!/usr/bin/env Rscript

# ============================================================
# Run omnideconv (scaden/scdc) on all per-donor references
# generated by prepare_perdonor_reference.py
#
# Usage:
#   Rscript deconvolution_perDonor.R <DATASET_NAME> <METHOD>
#     METHOD ∈ {scaden, scdc} <<< as a user, you can add more through omnideconv.
# ============================================================

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(omnideconv)
})
# ------------------------- args -------------------------
args <- commandArgs(trailingOnly = TRUE)
if (length(args) < 2) {
  stop("Usage: Rscript deconvolution_perDonor.R <DATASET_NAME> <METHOD>; METHOD ∈ {scaden, scdc}")
}
data_type   <- args[1]
raw_method  <- args[2]
method_norm <- tolower(raw_method)
if (!method_norm %in% c("scaden", "scdc", "cpm")) stop("METHOD must be 'scaden' or 'scdc' or 'cpm'")
method_key  <- method_norm              # for omnideconv
method_tag  <- toupper(method_norm)     # for filenames/logs

# ------------------------- transforms -------------------------
transformations <- c(
  "rawSN",
  "pcaSN",
  "degSN",
  "degOtherSN",
  "degIntSN",
  "degRandSN",
  "degPCA_SN",
  "scviSN",
  "scvi_LSshift_SN",
  "degScviSN",
  "degScviLSshift_SN",
  "degIntAllSN"
)

# ------------------------- paths -------------------------
script_dir  <- file.path(getwd(), "scripts")
import_path <- file.path(script_dir, "..", "data", "deconvolution", data_type)
export_path <- file.path(script_dir, "..", "results", data_type)
cat("Import path:", import_path, "\n")
cat("Export path:", export_path, "\n")
if (!dir.exists(export_path)) dir.create(export_path, recursive = TRUE)

# ------------------------- load bulks -------------------------
bulks_file <- file.path(import_path, "processed_bulks.csv")
if (!file.exists(bulks_file)) stop("Missing ", bulks_file)
mixture_data <- as.matrix(read.csv(bulks_file, row.names = 1, check.names = FALSE))
cat("Loaded bulks:", paste(dim(mixture_data), collapse = " x "), "\n")

# ------------------------- donors -------------------------
donors_csv <- file.path(import_path, "donors.csv")
if (!file.exists(donors_csv)) stop("Missing donors.csv at ", donors_csv)
line   <- readLines(donors_csv, n = 1)
donors <- strsplit(line, ",", fixed = TRUE)[[1]]

# ------------------------- runner -------------------------
run_one <- function(prefix, mixture_data, import_path, export_path, method_key, method_tag) {

  signal_file     <- file.path(import_path, paste0(prefix, "_signal.csv"))
  cell_state_file <- file.path(import_path, paste0(prefix, "_cell_state.csv"))

  if (!file.exists(signal_file) || !file.exists(cell_state_file)) {
    cat("Skipping:", prefix, "(missing files)\n")
    return(invisible(NULL))
  }
  ##REMOVE if you want to rerun
  out_file <- file.path(export_path, paste0(prefix, "_", method_tag, "_proportions.csv"))
  if (file.exists(out_file)) {
    cat("Skipping:", prefix, "(already done!)\n")
    return(invisible(NULL))
  }
  ##

  cat("\nProcessing:", prefix, "with", method_tag, "\n")
  signal_data <- read.csv(signal_file, row.names = 1, check.names = FALSE)
  cell_state  <- read.csv(cell_state_file, check.names = FALSE)

  # Intersect genes
  common_genes <- intersect(rownames(mixture_data), rownames(signal_data))
  if (length(common_genes) < 500) {
    cat("  Fewer than 500 overlapping genes; skipping.\n")
    return(invisible(NULL))
  }
  mixture_sub <- mixture_data[common_genes, , drop = FALSE]
  signal_sub  <- signal_data[common_genes, , drop = FALSE]

  # --- Build single-cell matrix (genes × cells) ---
  sc_mat <- as.matrix(signal_sub)        # genes × cells
  storage.mode(sc_mat) <- "double"

  # --- LONG cell_state like BP: column 1 = cell_type, rows = cells, same order as columns of sc_mat ---
  # --- cell_type comes from the named column 'cell_type' ---
  if (!"cell_type" %in% names(cell_state)) stop("cell_state.csv must have a 'cell_type' column.")
  labels <- as.character(cell_state[["cell_type"]])
  # --- Bulk matrix must be genes × samples ---
  bulk_gxs <- mixture_sub
  storage.mode(bulk_gxs) <- "double"
  batch_ids <- rep("batch1", ncol(sc_mat))

  # Deconvolution
  # --- One-step omnideconv---
  if (method_key %in% c("scdc", "cpm")) {    batch_ids <- rep("batch1", ncol(sc_mat))
    batch_ids <- rep("batch1", ncol(sc_mat))
    res <- omnideconv::deconvolute(
      bulk_gene_expression  = bulk_gxs,   # genes x samples
      method                = method_key,
      single_cell_object    = sc_mat,     # genes x cells
      cell_type_annotations = labels,     # length = ncol(sc_mat)
      batch_ids             = batch_ids,   # for SCDC but they are constant
      verbose = TRUE
    )
  } else {
    # scaden path (no batch_ids)
    signature <- omnideconv::build_model(
      sc_mat, labels,
      method = method_key,          
      bulk_gene_expression = bulk_gxs,
      verbose = TRUE
    )
    res <- omnideconv::deconvolute(bulk_gene_expression = bulk_gxs, model = signature,  method = method_key, verbose = TRUE)
  }

  # omnideconv returns cell_types x samples; save samples x cell_types
  out <- t(res)
  out_file <- file.path(export_path, paste0(prefix, "_", method_tag, "_proportions.csv"))
  write.table(out, out_file, sep = "\t", quote = FALSE, row.names = TRUE, col.names = NA)
  cat("  Saved:", out_file, "\n")
}

# ------------------------- loop donors x transforms -------------------------
for (d in donors) {
  cat("donor:", d, "\n")
  for (trans in transformations) {
    prefix <- paste0("ref_", d, "_", trans)
    run_one(prefix, mixture_data, import_path, export_path, method_key, method_tag)
  }
}

cat("\nAll per-donor references deconvolved with omnideconv (", method_tag, ").\n", sep = "")
